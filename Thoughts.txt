Написать базовую транзакционную отказоустойчивую систему

Методы:
1. Пополнить баланс пользователя
2. Перевести другому пользователю
3. Вывести с баланса

Сделать расчет баланса по транзакциям
При падении сервиса, транзакции которые еще не обработались, сохранять в какое-либо хранилище и восстанавливать при поднятии

------------------------------------------------------------------------------------------------

1. При получении запроса на сервере, сохраните его в Redis с уникальным идентификатором (например, UUID). В качестве значения можно использовать сериализованный JSON-объект с информацией о запросе.

2. Перед обработкой запроса, проверьте, есть ли сохраненная информация о нем в Redis. Если такая информация есть, значит запрос был сохранен ранее и не был завершен.

3. Если запрос был сохранен, возможно, он был прерван из-за падения сервера. Выполните необходимые действия для восстановления состояния и обработки запроса.

4. После успешной обработки запроса, удалите его из Redis.

5. Для обеспечения отказоустойчивости Redis, рекомендуется настроить его репликацию и перезапуск после сбоев. Это позволит сохранять данные даже при сбое основного сервера Redis.

------------------------------------------------------------------------------------------------

Сделать таблицу транзакций в бд, при запросе сохранять транзакцию и в кеш и в бд, потом проверять из кеша ее наличие в бд, восстанавливать бд и удалять кеш (как вариант)

func WithTransaction(db *sql.DB, fn TxFn) (err error) {
	tx, err := db.Begin()
	if err != nil {
		return
	}

	defer func() {
		if p := recover(); p != nil {
			// a panic occurred, rollback and repanic
			tx.Rollback()
			panic(p)
		} else if err != nil {
			// something went wrong, rollback
			tx.Rollback()
		} else {
			// all good, commit
			err = tx.Commit()
		}
	}()

	err = fn(tx)
	return err
}


ЗАКЕШИТЬ - КЛАСТЬ В БД - ЕСЛИ УПАДЕТ ОСТАВИТЬ КЕШ - ЕСЛИ ПРОЙДЕТ - УДАЛИТЬ КЕШ
